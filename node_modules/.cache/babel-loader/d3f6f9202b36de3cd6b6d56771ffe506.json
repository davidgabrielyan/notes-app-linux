{"ast":null,"code":"'use strict';\n\nconst Utils = require('../../utils');\n\nconst Transaction = require('../../transaction');\n\nconst _ = require('lodash');\n\nconst MySqlQueryGenerator = require('../mysql/query-generator');\n\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nclass SQLiteQueryGenerator extends MySqlQueryGenerator {\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  versionQuery() {\n    return 'SELECT sqlite_version() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = Object.values(attributes).filter(definition => definition.includes('PRIMARY KEY')).length > 1;\n    const attrArray = [];\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes('AUTOINCREMENT');\n        let dataTypeString = dataType;\n\n        if (dataType.includes('PRIMARY KEY')) {\n          if (dataType.includes('INT')) {\n            // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)\n            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';\n\n            if (dataType.includes(' REFERENCES')) {\n              dataTypeString += dataType.substr(dataType.indexOf(' REFERENCES'));\n            }\n          }\n\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n\n            if (dataType.includes('NOT NULL')) {\n              dataTypeString = dataType.replace(' PRIMARY KEY', '');\n            } else {\n              dataTypeString = dataType.replace('PRIMARY KEY', 'NOT NULL');\n            }\n          }\n        }\n\n        attrArray.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(dataTypeString));\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attrStr += \", UNIQUE (\".concat(columns.fields.map(field => this.quoteIdentifier(field)).join(', '), \")\");\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attrStr += \", PRIMARY KEY (\".concat(pkString, \")\");\n    }\n\n    const sql = \"CREATE TABLE IF NOT EXISTS \".concat(table, \" (\").concat(attrStr, \");\");\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    } // https://sqlite.org/json1.html\n\n\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    } // Check invalid json statement\n\n\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(\"Invalid json statement: \".concat(stmt));\n    } // return true if the statement has valid json function\n\n\n    return hasJsonFunction;\n  } //sqlite can't cast to datetime so we need to convert date values to their ISO strings\n\n\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n\n    if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map(val => val.toISOString());\n    }\n\n    return value;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n\n    if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      }\n    }\n\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, {\n      context: 'addColumn'\n    });\n    const attribute = \"\".concat(this.quoteIdentifier(key), \" \").concat(fields[key]);\n    const sql = \"ALTER TABLE \".concat(this.quoteTable(table), \" ADD \").concat(attribute, \";\");\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  showTablesQuery() {\n    return 'SELECT name FROM `sqlite_master` WHERE type=\\'table\\' and name!=\\'sqlite_sequence\\';';\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(\"\".concat(this.quoteIdentifier(key), \"=\").concat(this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, {\n          context: 'UPDATE'\n        })));\n      } else {\n        values.push(\"\".concat(this.quoteIdentifier(key), \"=\").concat(this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, {\n          context: 'UPDATE'\n        }, bindParam)));\n      }\n    }\n\n    let query;\n    const whereOptions = { ...options,\n      bindParam\n    };\n\n    if (options.limit) {\n      query = \"UPDATE \".concat(this.quoteTable(tableName), \" SET \").concat(values.join(','), \" WHERE rowid IN (SELECT rowid FROM \").concat(this.quoteTable(tableName), \" \").concat(this.whereQuery(where, whereOptions), \" LIMIT \").concat(this.escape(options.limit), \")\");\n    } else {\n      query = \"UPDATE \".concat(this.quoteTable(tableName), \" SET \").concat(values.join(','), \" \").concat(this.whereQuery(where, whereOptions));\n    }\n\n    return {\n      query,\n      bind\n    };\n  }\n\n  truncateTableQuery(tableName, options = {}) {\n    return [\"DELETE FROM \".concat(this.quoteTable(tableName)), options.restartIdentity ? \"; DELETE FROM \".concat(this.quoteTable('sqlite_sequence'), \" WHERE \").concat(this.quoteIdentifier('name'), \" = \").concat(Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), '`'), \"'\"), \";\") : ''].join('');\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    _.defaults(options, this.options);\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n\n    if (whereClause) {\n      whereClause = \"WHERE \".concat(whereClause);\n    }\n\n    if (options.limit) {\n      whereClause = \"WHERE rowid IN (SELECT rowid FROM \".concat(this.quoteTable(tableName), \" \").concat(whereClause, \" LIMIT \").concat(this.escape(options.limit), \")\");\n    }\n\n    return \"DELETE FROM \".concat(this.quoteTable(tableName), \" \").concat(whereClause);\n  }\n\n  attributesToSQL(attributes) {\n    const result = {};\n\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n\n        if (Object.prototype.hasOwnProperty.call(dataType, 'allowNull') && !dataType.allowNull) {\n          sql += ' NOT NULL';\n        }\n\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          // TODO thoroughly check that DataTypes.NOW will properly\n          // get populated on all databases as DEFAULT value\n          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP\n          sql += \" DEFAULT \".concat(this.escape(dataType.defaultValue, dataType));\n        }\n\n        if (dataType.unique === true) {\n          sql += ' UNIQUE';\n        }\n\n        if (dataType.primaryKey) {\n          sql += ' PRIMARY KEY';\n\n          if (dataType.autoIncrement) {\n            sql += ' AUTOINCREMENT';\n          }\n        }\n\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n          let referencesKey;\n\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier('id');\n          }\n\n          sql += \" REFERENCES \".concat(referencesTable, \" (\").concat(referencesKey, \")\");\n\n          if (dataType.onDelete) {\n            sql += \" ON DELETE \".concat(dataType.onDelete.toUpperCase());\n          }\n\n          if (dataType.onUpdate) {\n            sql += \" ON UPDATE \".concat(dataType.onUpdate.toUpperCase());\n          }\n        }\n\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n\n    return result;\n  }\n\n  showIndexesQuery(tableName) {\n    return \"PRAGMA INDEX_LIST(\".concat(this.quoteTable(tableName), \")\");\n  }\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = \"SELECT sql FROM sqlite_master WHERE tbl_name='\".concat(tableName, \"'\");\n\n    if (constraintName) {\n      sql += \" AND sql LIKE '%\".concat(constraintName, \"%'\");\n    }\n\n    return \"\".concat(sql, \";\");\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(\"\".concat(tableName, \"_\").concat(indexNameOrAttributes.join('_')));\n    }\n\n    return \"DROP INDEX IF EXISTS \".concat(this.quoteIdentifier(indexName));\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return \"PRAGMA TABLE_INFO(\".concat(this.quoteTable(this.addSchema(table)), \");\");\n  }\n\n  describeCreateTableQuery(tableName) {\n    return \"SELECT sql FROM sqlite_master WHERE tbl_name='\".concat(tableName, \"';\");\n  }\n\n  removeColumnQuery(tableName, attributes) {\n    attributes = this.attributesToSQL(attributes);\n    let backupTableName;\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: \"\".concat(tableName.tableName, \"_backup\"),\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = \"\".concat(tableName, \"_backup\");\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', '); // Temporary table cannot work for foreign keys.\n\n    return \"\".concat(this.createTableQuery(backupTableName, attributes), \"INSERT INTO \").concat(quotedBackupTableName, \" SELECT \").concat(attributeNames, \" FROM \").concat(quotedTableName, \";\") + \"DROP TABLE \".concat(quotedTableName, \";\").concat(this.createTableQuery(tableName, attributes), \"INSERT INTO \").concat(quotedTableName, \" SELECT \").concat(attributeNames, \" FROM \").concat(quotedBackupTableName, \";\") + \"DROP TABLE \".concat(quotedBackupTableName, \";\");\n  }\n\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: \"\".concat(tableName.tableName, \"_backup\"),\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = \"\".concat(tableName, \"_backup\");\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n    return \"\".concat(createTableSql.replace(\"CREATE TABLE \".concat(quotedTableName), \"CREATE TABLE \".concat(quotedBackupTableName)).replace(\"CREATE TABLE \".concat(quotedTableName.replace(/`/g, '\"')), \"CREATE TABLE \".concat(quotedBackupTableName)), \"INSERT INTO \").concat(quotedBackupTableName, \" SELECT \").concat(attributeNames, \" FROM \").concat(quotedTableName, \";\") + \"DROP TABLE \".concat(quotedTableName, \";\") + \"ALTER TABLE \".concat(quotedBackupTableName, \" RENAME TO \").concat(quotedTableName, \";\");\n  }\n\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: \"\".concat(tableName.tableName, \"_backup\"),\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = \"\".concat(tableName, \"_backup\");\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr => attrNameAfter === attr ? \"\".concat(this.quoteIdentifier(attrNameBefore), \" AS \").concat(this.quoteIdentifier(attr)) : this.quoteIdentifier(attr)).join(', ');\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', '); // Temporary tables don't support foreign keys, so creating a temporary table will not allow foreign keys to be preserved\n\n    return \"\".concat(this.createTableQuery(backupTableName, attributes), \"INSERT INTO \").concat(quotedBackupTableName, \" SELECT \").concat(attributeNamesImport, \" FROM \").concat(quotedTableName, \";\") + \"DROP TABLE \".concat(quotedTableName, \";\").concat(this.createTableQuery(tableName, attributes), \"INSERT INTO \").concat(quotedTableName, \" SELECT \").concat(attributeNamesExport, \" FROM \").concat(quotedBackupTableName, \";\") + \"DROP TABLE \".concat(quotedBackupTableName, \";\");\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return \"SAVEPOINT \".concat(this.quoteIdentifier(transaction.name), \";\");\n    }\n\n    return \"BEGIN \".concat(transaction.options.type, \" TRANSACTION;\");\n  }\n\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';\n\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return 'PRAGMA read_uncommitted = ON;';\n\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'PRAGMA read_uncommitted = OFF;';\n\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return '-- SQLite\\'s default isolation level is SERIALIZABLE. Nothing to do.';\n\n      default:\n        throw new Error(\"Unknown isolation level: \".concat(value));\n    }\n  }\n\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');\n  }\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n\n\n  getForeignKeysQuery(tableName) {\n    return \"PRAGMA foreign_key_list(\".concat(tableName, \")\");\n  }\n\n}\n\nmodule.exports = SQLiteQueryGenerator;","map":null,"metadata":{},"sourceType":"script"}