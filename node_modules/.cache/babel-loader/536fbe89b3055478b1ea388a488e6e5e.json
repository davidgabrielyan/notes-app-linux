{"ast":null,"code":"'use strict';\n\nconst Packet = require('./packets/packet.js');\n\nconst MAX_PACKET_LENGTH = 16777215;\n\nfunction readPacketLength(b, off) {\n  const b0 = b[off];\n  const b1 = b[off + 1];\n  const b2 = b[off + 2];\n\n  if (b1 + b2 === 0) {\n    return b0;\n  }\n\n  return b0 + (b1 << 8) + (b2 << 16);\n}\n\nclass PacketParser {\n  constructor(onPacket, packetHeaderLength) {\n    // 4 for normal packets, 7 for comprssed protocol packets\n    if (typeof packetHeaderLength === 'undefined') {\n      packetHeaderLength = 4;\n    } // array of last payload chunks\n    // only used when current payload is not complete\n\n\n    this.buffer = []; // total length of chunks on buffer\n\n    this.bufferLength = 0;\n    this.packetHeaderLength = packetHeaderLength; // incomplete header state: number of header bytes received\n\n    this.headerLen = 0; // expected payload length\n\n    this.length = 0;\n    this.largePacketParts = [];\n    this.firstPacketSequenceId = 0;\n    this.onPacket = onPacket;\n    this.execute = PacketParser.prototype.executeStart;\n    this._flushLargePacket = packetHeaderLength === 7 ? this._flushLargePacket7 : this._flushLargePacket4;\n  }\n\n  _flushLargePacket4() {\n    const numPackets = this.largePacketParts.length;\n    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0])); // insert header\n\n    const body = Buffer.concat(this.largePacketParts);\n    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n    this.largePacketParts.length = 0;\n    packet.numPackets = numPackets;\n    this.onPacket(packet);\n  }\n\n  _flushLargePacket7() {\n    const numPackets = this.largePacketParts.length;\n    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0, 0, 0, 0])); // insert header\n\n    const body = Buffer.concat(this.largePacketParts);\n    this.largePacketParts.length = 0;\n    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n    packet.numPackets = numPackets;\n    this.onPacket(packet);\n  }\n\n  executeStart(chunk) {\n    let start = 0;\n    const end = chunk.length;\n\n    while (end - start >= 3) {\n      this.length = readPacketLength(chunk, start);\n\n      if (end - start >= this.length + this.packetHeaderLength) {\n        // at least one full packet\n        const sequenceId = chunk[start + 3];\n\n        if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) {\n          this.onPacket(new Packet(sequenceId, chunk, start, start + this.packetHeaderLength + this.length));\n        } else {\n          // first large packet - remember it's id\n          if (this.largePacketParts.length === 0) {\n            this.firstPacketSequenceId = sequenceId;\n          }\n\n          this.largePacketParts.push(chunk.slice(start + this.packetHeaderLength, start + this.packetHeaderLength + this.length));\n\n          if (this.length < MAX_PACKET_LENGTH) {\n            this._flushLargePacket();\n          }\n        }\n\n        start += this.packetHeaderLength + this.length;\n      } else {\n        // payload is incomplete\n        this.buffer = [chunk.slice(start + 3, end)];\n        this.bufferLength = end - start - 3;\n        this.execute = PacketParser.prototype.executePayload;\n        return;\n      }\n    }\n\n    if (end - start > 0) {\n      // there is start of length header, but it's not full 3 bytes\n      this.headerLen = end - start; // 1 or 2 bytes\n\n      this.length = chunk[start];\n\n      if (this.headerLen === 2) {\n        this.length = chunk[start] + (chunk[start + 1] << 8);\n        this.execute = PacketParser.prototype.executeHeader3;\n      } else {\n        this.execute = PacketParser.prototype.executeHeader2;\n      }\n    }\n  }\n\n  executePayload(chunk) {\n    let start = 0;\n    const end = chunk.length;\n    const remainingPayload = this.length - this.bufferLength + this.packetHeaderLength - 3;\n\n    if (end - start >= remainingPayload) {\n      // last chunk for payload\n      const payload = Buffer.allocUnsafe(this.length + this.packetHeaderLength);\n      let offset = 3;\n\n      for (let i = 0; i < this.buffer.length; ++i) {\n        this.buffer[i].copy(payload, offset);\n        offset += this.buffer[i].length;\n      }\n\n      chunk.copy(payload, offset, start, start + remainingPayload);\n      const sequenceId = payload[3];\n\n      if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) {\n        this.onPacket(new Packet(sequenceId, payload, 0, this.length + this.packetHeaderLength));\n      } else {\n        // first large packet - remember it's id\n        if (this.largePacketParts.length === 0) {\n          this.firstPacketSequenceId = sequenceId;\n        }\n\n        this.largePacketParts.push(payload.slice(this.packetHeaderLength, this.packetHeaderLength + this.length));\n\n        if (this.length < MAX_PACKET_LENGTH) {\n          this._flushLargePacket();\n        }\n      }\n\n      this.buffer = [];\n      this.bufferLength = 0;\n      this.execute = PacketParser.prototype.executeStart;\n      start += remainingPayload;\n\n      if (end - start > 0) {\n        return this.execute(chunk.slice(start, end));\n      }\n    } else {\n      this.buffer.push(chunk);\n      this.bufferLength += chunk.length;\n    }\n\n    return null;\n  }\n\n  executeHeader2(chunk) {\n    this.length += chunk[0] << 8;\n\n    if (chunk.length > 1) {\n      this.length += chunk[1] << 16;\n      this.execute = PacketParser.prototype.executePayload;\n      return this.executePayload(chunk.slice(2));\n    }\n\n    this.execute = PacketParser.prototype.executeHeader3;\n    return null;\n  }\n\n  executeHeader3(chunk) {\n    this.length += chunk[0] << 16;\n    this.execute = PacketParser.prototype.executePayload;\n    return this.executePayload(chunk.slice(1));\n  }\n\n}\n\nmodule.exports = PacketParser;","map":null,"metadata":{},"sourceType":"script"}