{"ast":null,"code":"'use strict';\n\nconst urlParse = require('url').parse;\n\nconst ClientConstants = require('./constants/client');\n\nconst Charsets = require('./constants/charsets');\n\nlet SSLProfiles = null;\nconst validOptions = {\n  authPlugins: 1,\n  authSwitchHandler: 1,\n  bigNumberStrings: 1,\n  charset: 1,\n  charsetNumber: 1,\n  compress: 1,\n  connectAttributes: 1,\n  connectTimeout: 1,\n  database: 1,\n  dateStrings: 1,\n  debug: 1,\n  decimalNumbers: 1,\n  enableKeepAlive: 1,\n  flags: 1,\n  host: 1,\n  insecureAuth: 1,\n  isServer: 1,\n  keepAliveInitialDelay: 1,\n  localAddress: 1,\n  maxPreparedStatements: 1,\n  multipleStatements: 1,\n  namedPlaceholders: 1,\n  nestTables: 1,\n  password: 1,\n  passwordSha1: 1,\n  pool: 1,\n  port: 1,\n  queryFormat: 1,\n  rowsAsArray: 1,\n  socketPath: 1,\n  ssl: 1,\n  stream: 1,\n  stringifyObjects: 1,\n  supportBigNumbers: 1,\n  timezone: 1,\n  trace: 1,\n  typeCast: 1,\n  uri: 1,\n  user: 1,\n  // These options are used for Pool\n  connectionLimit: 1,\n  Promise: 1,\n  queueLimit: 1,\n  waitForConnections: 1\n};\n\nclass ConnectionConfig {\n  constructor(options) {\n    if (typeof options === 'string') {\n      options = ConnectionConfig.parseUrl(options);\n    } else if (options && options.uri) {\n      const uriOptions = ConnectionConfig.parseUrl(options.uri);\n\n      for (const key in uriOptions) {\n        if (!Object.prototype.hasOwnProperty.call(uriOptions, key)) continue;\n        if (options[key]) continue;\n        options[key] = uriOptions[key];\n      }\n    }\n\n    for (const key in options) {\n      if (!Object.prototype.hasOwnProperty.call(options, key)) continue;\n\n      if (validOptions[key] !== 1) {\n        // REVIEW: Should this be emitted somehow?\n        // eslint-disable-next-line no-console\n        console.error(\"Ignoring invalid configuration option passed to Connection: \".concat(key, \". This is currently a warning, but in future versions of MySQL2, an error will be thrown if you pass an invalid configuration option to a Connection\"));\n      }\n    }\n\n    this.isServer = options.isServer;\n    this.stream = options.stream;\n    this.host = options.host || 'localhost';\n    this.port = options.port || 3306;\n    this.localAddress = options.localAddress;\n    this.socketPath = options.socketPath;\n    this.user = options.user || undefined;\n    this.password = options.password || undefined;\n    this.passwordSha1 = options.passwordSha1 || undefined;\n    this.database = options.database;\n    this.connectTimeout = isNaN(options.connectTimeout) ? 10 * 1000 : options.connectTimeout;\n    this.insecureAuth = options.insecureAuth || false;\n    this.supportBigNumbers = options.supportBigNumbers || false;\n    this.bigNumberStrings = options.bigNumberStrings || false;\n    this.decimalNumbers = options.decimalNumbers || false;\n    this.dateStrings = options.dateStrings || false;\n    this.debug = options.debug;\n    this.trace = options.trace !== false;\n    this.stringifyObjects = options.stringifyObjects || false;\n    this.enableKeepAlive = !!options.enableKeepAlive;\n    this.keepAliveInitialDelay = options.keepAliveInitialDelay || 0;\n\n    if (options.timezone && !/^(?:local|Z|[ +-]\\d\\d:\\d\\d)$/.test(options.timezone)) {\n      // strictly supports timezones specified by mysqljs/mysql:\n      // https://github.com/mysqljs/mysql#user-content-connection-options\n      // eslint-disable-next-line no-console\n      console.error(\"Ignoring invalid timezone passed to Connection: \".concat(options.timezone, \". This is currently a warning, but in future versions of MySQL2, an error will be thrown if you pass an invalid configuration option to a Connection\")); // SqlStrings falls back to UTC on invalid timezone\n\n      this.timezone = 'Z';\n    } else {\n      this.timezone = options.timezone || 'local';\n    }\n\n    this.queryFormat = options.queryFormat;\n    this.pool = options.pool || undefined;\n    this.ssl = typeof options.ssl === 'string' ? ConnectionConfig.getSSLProfile(options.ssl) : options.ssl || false;\n    this.multipleStatements = options.multipleStatements || false;\n    this.rowsAsArray = options.rowsAsArray || false;\n    this.namedPlaceholders = options.namedPlaceholders || false;\n    this.nestTables = options.nestTables === undefined ? undefined : options.nestTables;\n    this.typeCast = options.typeCast === undefined ? true : options.typeCast;\n\n    if (this.timezone[0] === ' ') {\n      // \"+\" is a url encoded char for space so it\n      // gets translated to space when giving a\n      // connection string..\n      this.timezone = \"+\".concat(this.timezone.substr(1));\n    }\n\n    if (this.ssl) {\n      if (typeof this.ssl !== 'object') {\n        throw new TypeError(\"SSL profile must be an object, instead it's a \".concat(typeof this.ssl));\n      } // Default rejectUnauthorized to true\n\n\n      this.ssl.rejectUnauthorized = this.ssl.rejectUnauthorized !== false;\n    }\n\n    this.maxPacketSize = 0;\n    this.charsetNumber = options.charset ? ConnectionConfig.getCharsetNumber(options.charset) : options.charsetNumber || Charsets.UTF8MB4_UNICODE_CI;\n    this.compress = options.compress || false;\n    this.authPlugins = options.authPlugins;\n    this.authSwitchHandler = options.authSwitchHandler;\n    this.clientFlags = ConnectionConfig.mergeFlags(ConnectionConfig.getDefaultFlags(options), options.flags || '');\n    this.connectAttributes = options.connectAttributes;\n    this.maxPreparedStatements = options.maxPreparedStatements || 16000;\n  }\n\n  static mergeFlags(default_flags, user_flags) {\n    let flags = 0x0,\n        i;\n\n    if (!Array.isArray(user_flags)) {\n      user_flags = String(user_flags || '').toUpperCase().split(/\\s*,+\\s*/);\n    } // add default flags unless \"blacklisted\"\n\n\n    for (i in default_flags) {\n      if (user_flags.indexOf(\"-\".concat(default_flags[i])) >= 0) {\n        continue;\n      }\n\n      flags |= ClientConstants[default_flags[i]] || 0x0;\n    } // add user flags unless already already added\n\n\n    for (i in user_flags) {\n      if (user_flags[i][0] === '-') {\n        continue;\n      }\n\n      if (default_flags.indexOf(user_flags[i]) >= 0) {\n        continue;\n      }\n\n      flags |= ClientConstants[user_flags[i]] || 0x0;\n    }\n\n    return flags;\n  }\n\n  static getDefaultFlags(options) {\n    const defaultFlags = ['LONG_PASSWORD', 'FOUND_ROWS', 'LONG_FLAG', 'CONNECT_WITH_DB', 'ODBC', 'LOCAL_FILES', 'IGNORE_SPACE', 'PROTOCOL_41', 'IGNORE_SIGPIPE', 'TRANSACTIONS', 'RESERVED', 'SECURE_CONNECTION', 'MULTI_RESULTS', 'TRANSACTIONS', 'SESSION_TRACK'];\n\n    if (options && options.multipleStatements) {\n      defaultFlags.push('MULTI_STATEMENTS');\n    }\n\n    defaultFlags.push('PLUGIN_AUTH');\n    defaultFlags.push('PLUGIN_AUTH_LENENC_CLIENT_DATA');\n\n    if (options && options.connectAttributes) {\n      defaultFlags.push('CONNECT_ATTRS');\n    }\n\n    return defaultFlags;\n  }\n\n  static getCharsetNumber(charset) {\n    const num = Charsets[charset.toUpperCase()];\n\n    if (num === undefined) {\n      throw new TypeError(\"Unknown charset '\".concat(charset, \"'\"));\n    }\n\n    return num;\n  }\n\n  static getSSLProfile(name) {\n    if (!SSLProfiles) {\n      SSLProfiles = require('./constants/ssl_profiles.js');\n    }\n\n    const ssl = SSLProfiles[name];\n\n    if (ssl === undefined) {\n      throw new TypeError(\"Unknown SSL profile '\".concat(name, \"'\"));\n    }\n\n    return ssl;\n  }\n\n  static parseUrl(url) {\n    url = urlParse(url, true);\n    const options = {\n      host: url.hostname,\n      port: url.port,\n      database: url.pathname.substr(1)\n    };\n\n    if (url.auth) {\n      const auth = url.auth.split(':');\n      options.user = auth[0];\n      options.password = auth[1];\n    }\n\n    if (url.query) {\n      for (const key in url.query) {\n        const value = url.query[key];\n\n        try {\n          // Try to parse this as a JSON expression first\n          options[key] = JSON.parse(value);\n        } catch (err) {\n          // Otherwise assume it is a plain string\n          options[key] = value;\n        }\n      }\n    }\n\n    return options;\n  }\n\n}\n\nmodule.exports = ConnectionConfig;","map":null,"metadata":{},"sourceType":"script"}