{"ast":null,"code":"'use strict';\n\nconst process = require('process');\n\nconst Pool = require('./pool.js');\n\nconst PoolConfig = require('./pool_config.js');\n\nconst EventEmitter = require('events').EventEmitter;\n/**\n * Selector\n */\n\n\nconst makeSelector = {\n  RR() {\n    let index = 0;\n    return clusterIds => clusterIds[index++ % clusterIds.length];\n  },\n\n  RANDOM() {\n    return clusterIds => clusterIds[Math.floor(Math.random() * clusterIds.length)];\n  },\n\n  ORDER() {\n    return clusterIds => clusterIds[0];\n  }\n\n};\n\nclass PoolNamespace {\n  constructor(cluster, pattern, selector) {\n    this._cluster = cluster;\n    this._pattern = pattern;\n    this._selector = makeSelector[selector]();\n  }\n\n  getConnection(cb) {\n    const clusterNode = this._getClusterNode();\n\n    if (clusterNode === null) {\n      return cb(new Error('Pool does Not exists.'));\n    }\n\n    return this._cluster._getConnection(clusterNode, (err, connection) => {\n      if (err) {\n        return cb(err);\n      }\n\n      if (connection === 'retry') {\n        return this.getConnection(cb);\n      }\n\n      return cb(null, connection);\n    });\n  }\n\n  _getClusterNode() {\n    const foundNodeIds = this._cluster._findNodeIds(this._pattern);\n\n    if (foundNodeIds.length === 0) {\n      return null;\n    }\n\n    const nodeId = foundNodeIds.length === 1 ? foundNodeIds[0] : this._selector(foundNodeIds);\n    return this._cluster._getNode(nodeId);\n  }\n\n}\n\nclass PoolCluster extends EventEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this._canRetry = typeof config.canRetry === 'undefined' ? true : config.canRetry;\n    this._removeNodeErrorCount = config.removeNodeErrorCount || 5;\n    this._defaultSelector = config.defaultSelector || 'RR';\n    this._closed = false;\n    this._lastId = 0;\n    this._nodes = {};\n    this._serviceableNodeIds = [];\n    this._namespaces = {};\n    this._findCaches = {};\n  }\n\n  of(pattern, selector) {\n    pattern = pattern || '*';\n    selector = selector || this._defaultSelector;\n    selector = selector.toUpperCase();\n\n    if (!makeSelector[selector] === 'undefined') {\n      selector = this._defaultSelector;\n    }\n\n    const key = pattern + selector;\n\n    if (typeof this._namespaces[key] === 'undefined') {\n      this._namespaces[key] = new PoolNamespace(this, pattern, selector);\n    }\n\n    return this._namespaces[key];\n  }\n\n  add(id, config) {\n    if (typeof id === 'object') {\n      config = id;\n      id = \"CLUSTER::\".concat(++this._lastId);\n    }\n\n    if (typeof this._nodes[id] === 'undefined') {\n      this._nodes[id] = {\n        id: id,\n        errorCount: 0,\n        pool: new Pool({\n          config: new PoolConfig(config)\n        })\n      };\n\n      this._serviceableNodeIds.push(id);\n\n      this._clearFindCaches();\n    }\n  }\n\n  getConnection(pattern, selector, cb) {\n    let namespace;\n\n    if (typeof pattern === 'function') {\n      cb = pattern;\n      namespace = this.of();\n    } else {\n      if (typeof selector === 'function') {\n        cb = selector;\n        selector = this._defaultSelector;\n      }\n\n      namespace = this.of(pattern, selector);\n    }\n\n    namespace.getConnection(cb);\n  }\n\n  end(callback) {\n    const cb = callback !== undefined ? callback : err => {\n      if (err) {\n        throw err;\n      }\n    };\n\n    if (this._closed) {\n      process.nextTick(cb);\n      return;\n    }\n\n    this._closed = true;\n    let calledBack = false;\n    let waitingClose = 0;\n\n    const onEnd = err => {\n      if (!calledBack && (err || --waitingClose <= 0)) {\n        calledBack = true;\n        return cb(err);\n      }\n    };\n\n    for (const id in this._nodes) {\n      waitingClose++;\n\n      this._nodes[id].pool.end(onEnd);\n    }\n\n    if (waitingClose === 0) {\n      process.nextTick(onEnd);\n    }\n  }\n\n  _findNodeIds(pattern) {\n    if (typeof this._findCaches[pattern] !== 'undefined') {\n      return this._findCaches[pattern];\n    }\n\n    let foundNodeIds;\n\n    if (pattern === '*') {\n      // all\n      foundNodeIds = this._serviceableNodeIds;\n    } else if (this._serviceableNodeIds.indexOf(pattern) !== -1) {\n      // one\n      foundNodeIds = [pattern];\n    } else {\n      // wild matching\n      const keyword = pattern.substring(pattern.length - 1, 0);\n      foundNodeIds = this._serviceableNodeIds.filter(id => id.startsWith(keyword));\n    }\n\n    this._findCaches[pattern] = foundNodeIds;\n    return foundNodeIds;\n  }\n\n  _getNode(id) {\n    return this._nodes[id] || null;\n  }\n\n  _increaseErrorCount(node) {\n    if (++node.errorCount >= this._removeNodeErrorCount) {\n      const index = this._serviceableNodeIds.indexOf(node.id);\n\n      if (index !== -1) {\n        this._serviceableNodeIds.splice(index, 1);\n\n        delete this._nodes[node.id];\n\n        this._clearFindCaches();\n\n        node.pool.end();\n        this.emit('remove', node.id);\n      }\n    }\n  }\n\n  _decreaseErrorCount(node) {\n    if (node.errorCount > 0) {\n      --node.errorCount;\n    }\n  }\n\n  _getConnection(node, cb) {\n    node.pool.getConnection((err, connection) => {\n      if (err) {\n        this._increaseErrorCount(node);\n\n        if (this._canRetry) {\n          // REVIEW: this seems wrong?\n          this.emit('warn', err); // eslint-disable-next-line no-console\n\n          console.warn(\"[Error] PoolCluster : \".concat(err));\n          return cb(null, 'retry');\n        }\n\n        return cb(err);\n      }\n\n      this._decreaseErrorCount(node);\n\n      connection._clusterId = node.id;\n      return cb(null, connection);\n    });\n  }\n\n  _clearFindCaches() {\n    this._findCaches = {};\n  }\n\n}\n\nmodule.exports = PoolCluster;","map":null,"metadata":{},"sourceType":"script"}