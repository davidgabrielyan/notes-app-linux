{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('../../utils');\n\nconst AbstractQuery = require('../abstract/query');\n\nconst QueryTypes = require('../../query-types');\n\nconst sequelizeErrors = require('../../errors');\n\nconst parserStore = require('../parserStore')('sqlite');\n\nconst _require = require('../../utils/logger'),\n      logger = _require.logger;\n\nconst debug = logger.debugContext('sql:sqlite');\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return 'lastID';\n  }\n  /**\n   * rewrite query with parameters.\n   *\n   * @param {string} sql\n   * @param {Array|object} values\n   * @param {string} dialect\n   * @private\n   */\n\n\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[\"$\".concat(i + 1)] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n        skipValueReplace: true\n      })[0];\n    } else {\n      bindParam = {};\n\n      if (typeof values === 'object') {\n        for (const k of Object.keys(values)) {\n          bindParam[\"$\".concat(k)] = values[k];\n        }\n      }\n\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n        skipValueReplace: true\n      })[0];\n    }\n\n    return [sql, bindParam];\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = \"\".concat(prefix, \".\").concat(_include.as);\n        }\n\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  _handleQueryResponse(metaData, columnTypes, err, results) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err);\n    }\n\n    let result = this.instance; // add the inserted row id to the instance\n\n    if (this.isInsertQuery(results, metaData)) {\n      this.handleInsertQuery(results, metaData);\n\n      if (!this.instance) {\n        // handle bulkCreate AI primary key\n        if (metaData.constructor.name === 'Statement' && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({\n              [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i\n            });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      return results.map(row => row.name);\n    }\n\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n\n      return result;\n    }\n\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      } // This is a map of prefix strings to models, e.g. user.projects -> Project model\n\n\n      const prefixes = this._collectModels(this.options.include);\n\n      results = results.map(result => {\n        return _.mapValues(result, (value, name) => {\n          let model;\n\n          if (name.includes('.')) {\n            const lastind = name.lastIndexOf('.');\n            model = prefixes[name.substr(0, lastind)];\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n\n          const tableName = model.getTableName().toString().replace(/`/g, '');\n          const tableTypes = columnTypes[tableName] || {};\n\n          if (tableTypes && !(name in tableTypes)) {\n            // The column is aliased\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n\n          return Object.prototype.hasOwnProperty.call(tableTypes, name) ? this.applyParsers(tableTypes[name], value) : value;\n        });\n      });\n      return this.handleSelectQuery(results);\n    }\n\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n\n    if (this.sql.includes('PRAGMA INDEX_LIST')) {\n      return this.handleShowIndexesQuery(results);\n    }\n\n    if (this.sql.includes('PRAGMA INDEX_INFO')) {\n      return results;\n    }\n\n    if (this.sql.includes('PRAGMA TABLE_INFO')) {\n      // this is the sqlite way of getting the metadata of a table\n      result = {};\n      let defaultValue;\n\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          // Column schema omits any \"DEFAULT ...\"\n          defaultValue = undefined;\n        } else if (_result.dflt_value === 'NULL') {\n          // Column schema is a \"DEFAULT NULL\"\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n\n        if (result[_result.name].type === 'TINYINT(1)') {\n          result[_result.name].defaultValue = {\n            '0': false,\n            '1': true\n          }[result[_result.name].defaultValue];\n        }\n\n        if (typeof result[_result.name].defaultValue === 'string') {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');\n        }\n      }\n\n      return result;\n    }\n\n    if (this.sql.includes('PRAGMA foreign_keys;')) {\n      return results[0];\n    }\n\n    if (this.sql.includes('PRAGMA foreign_keys')) {\n      return results;\n    }\n\n    if (this.sql.includes('PRAGMA foreign_key_list')) {\n      return results;\n    }\n\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n\n    return result;\n  }\n\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    let complete;\n\n    if (method === 'exec') {\n      // exec does not support bind parameter\n      sql = AbstractQuery.formatBindParameters(sql, this.options.bind, this.options.dialect || 'sqlite', {\n        skipUnescape: true\n      })[0];\n      this.sql = sql;\n      complete = this._logQuery(sql, debug);\n    } else {\n      complete = this._logQuery(sql, debug, parameters);\n    }\n\n    return new Promise((resolve, reject) => conn.serialize(async () => {\n      const columnTypes = {};\n\n      const executeSql = () => {\n        if (sql.startsWith('-- ')) {\n          return resolve();\n        }\n\n        const query = this; // cannot use arrow function here because the function is bound to the statement\n\n        function afterExecute(executionError, results) {\n          try {\n            complete(); // `this` is passed from sqlite, we have no control over this.\n            // eslint-disable-next-line no-invalid-this\n\n            resolve(query._handleQueryResponse(this, columnTypes, executionError, results));\n            return;\n          } catch (error) {\n            reject(error);\n          }\n        }\n\n        if (method === 'exec') {\n          // exec does not support bind parameter\n          conn[method](sql, afterExecute);\n        } else {\n          if (!parameters) parameters = [];\n          conn[method](sql, parameters, afterExecute);\n        }\n\n        return null;\n      };\n\n      if (this.getDatabaseMethod() === 'all') {\n        let tableNames = [];\n\n        if (this.options && this.options.tableNames) {\n          tableNames = this.options.tableNames;\n        } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n        } // If we already have the metadata for the table, there's no need to ask for it again\n\n\n        tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');\n\n        if (!tableNames.length) {\n          return executeSql();\n        }\n\n        await Promise.all(tableNames.map(tableName => new Promise(resolve => {\n          tableName = tableName.replace(/`/g, '');\n          columnTypes[tableName] = {};\n          conn.all(\"PRAGMA table_info(`\".concat(tableName, \"`)\"), (err, results) => {\n            if (!err) {\n              for (const result of results) {\n                columnTypes[tableName][result.name] = result.type;\n              }\n            }\n\n            resolve();\n          });\n        })));\n      }\n\n      return executeSql();\n    }));\n  }\n\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split('CONSTRAINT ');\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      //Parse foreign key snippets\n      if (constraintSql.includes('REFERENCES')) {\n        //Parse out the constraint condition form sql string\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, '').split(', ');\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, '');\n      const constraint = constraintSql.split(' ');\n\n      if (constraint[1] === 'PRIMARY' || constraint[1] === 'FOREIGN') {\n        constraint[1] += ' KEY';\n      }\n\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, '`'),\n        //Sqlite returns double quotes for table name\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n    return constraints;\n  }\n\n  applyParsers(type, value) {\n    if (type.includes('(')) {\n      // Remove the length part\n      type = type.substr(0, type.indexOf('('));\n    }\n\n    type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n\n    if (value !== null && parse) {\n      return parse(value, {\n        timezone: this.sequelize.options.timezone\n      });\n    }\n\n    return value;\n  }\n\n  formatError(err) {\n    switch (err.code) {\n      case 'SQLITE_CONSTRAINT':\n        {\n          if (err.message.includes('FOREIGN KEY constraint failed')) {\n            return new sequelizeErrors.ForeignKeyConstraintError({\n              parent: err\n            });\n          }\n\n          let fields = []; // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique\n\n          let match = err.message.match(/columns (.*?) are/);\n\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(', ');\n          } else {\n            // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y\n            match = err.message.match(/UNIQUE constraint failed: (.*)/);\n\n            if (match !== null && match.length >= 2) {\n              fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);\n            }\n          }\n\n          const errors = [];\n          let message = 'Validation error';\n\n          for (const field of fields) {\n            errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), 'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n            field, this.instance && this.instance[field], this.instance, 'not_unique'));\n          }\n\n          if (this.model) {\n            _.forOwn(this.model.uniqueKeys, constraint => {\n              if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n                message = constraint.msg;\n                return false;\n              }\n            });\n          }\n\n          return new sequelizeErrors.UniqueConstraintError({\n            message,\n            errors,\n            parent: err,\n            fields\n          });\n        }\n\n      case 'SQLITE_BUSY':\n        return new sequelizeErrors.TimeoutError(err);\n\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n\n  async handleShowIndexesQuery(data) {\n    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!\n    return Promise.all(data.reverse().map(async item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      const columns = await this.run(\"PRAGMA INDEX_INFO(`\".concat(item.name, \"`)\"));\n\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: undefined,\n          order: undefined\n        };\n      }\n\n      return item;\n    }));\n  }\n\n  getDatabaseMethod() {\n    if (this.isUpsertQuery()) {\n      return 'exec'; // Needed to run multiple queries in one\n    }\n\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return 'run';\n    }\n\n    return 'all';\n  }\n\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;","map":null,"metadata":{},"sourceType":"script"}