{"ast":null,"code":"var EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar DEFAULT_TIMEOUT = 3000;\nvar INIT_ID = 0;\nvar EVENT_CLOSED = 'closed';\nvar EVENT_DRAINED = 'drained';\n/**\n * Instance a new queue\n *\n * @param {Number} timeout a global timeout for new queue\n * @class\n * @constructor\n */\n\nvar SeqQueue = function (timeout) {\n  EventEmitter.call(this);\n\n  if (timeout && timeout > 0) {\n    this.timeout = timeout;\n  } else {\n    this.timeout = DEFAULT_TIMEOUT;\n  }\n\n  this.status = SeqQueueManager.STATUS_IDLE;\n  this.curId = INIT_ID;\n  this.queue = [];\n};\n\nutil.inherits(SeqQueue, EventEmitter);\n/**\n * Add a task into queue.\n * \n * @param fn new request\n * @param ontimeout callback when task timeout\n * @param timeout timeout for current request. take the global timeout if this is invalid\n * @returns true or false\n */\n\nSeqQueue.prototype.push = function (fn, ontimeout, timeout) {\n  if (this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {\n    //ignore invalid status\n    return false;\n  }\n\n  if (typeof fn !== 'function') {\n    throw new Error('fn should be a function.');\n  }\n\n  this.queue.push({\n    fn: fn,\n    ontimeout: ontimeout,\n    timeout: timeout\n  });\n\n  if (this.status === SeqQueueManager.STATUS_IDLE) {\n    this.status = SeqQueueManager.STATUS_BUSY;\n    var self = this;\n    process.nextTick(function () {\n      self._next(self.curId);\n    });\n  }\n\n  return true;\n};\n/**\n * Close queue\n * \n * @param {Boolean} force if true will close the queue immediately else will execute the rest task in queue\n */\n\n\nSeqQueue.prototype.close = function (force) {\n  if (this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {\n    //ignore invalid status\n    return;\n  }\n\n  if (force) {\n    this.status = SeqQueueManager.STATUS_DRAINED;\n\n    if (this.timerId) {\n      clearTimeout(this.timerId);\n      this.timerId = undefined;\n    }\n\n    this.emit(EVENT_DRAINED);\n  } else {\n    this.status = SeqQueueManager.STATUS_CLOSED;\n    this.emit(EVENT_CLOSED);\n  }\n};\n/**\n * Invoke next task\n * \n * @param {String|Number} tid last executed task id\n * @api private\n */\n\n\nSeqQueue.prototype._next = function (tid) {\n  if (tid !== this.curId || this.status !== SeqQueueManager.STATUS_BUSY && this.status !== SeqQueueManager.STATUS_CLOSED) {\n    //ignore invalid next call\n    return;\n  }\n\n  if (this.timerId) {\n    clearTimeout(this.timerId);\n    this.timerId = undefined;\n  }\n\n  var task = this.queue.shift();\n\n  if (!task) {\n    if (this.status === SeqQueueManager.STATUS_BUSY) {\n      this.status = SeqQueueManager.STATUS_IDLE;\n      this.curId++; //modify curId to invalidate timeout task\n    } else {\n      this.status = SeqQueueManager.STATUS_DRAINED;\n      this.emit(EVENT_DRAINED);\n    }\n\n    return;\n  }\n\n  var self = this;\n  task.id = ++this.curId;\n  var timeout = task.timeout > 0 ? task.timeout : this.timeout;\n  timeout = timeout > 0 ? timeout : DEFAULT_TIMEOUT;\n  this.timerId = setTimeout(function () {\n    process.nextTick(function () {\n      self._next(task.id);\n    });\n    self.emit('timeout', task);\n\n    if (task.ontimeout) {\n      task.ontimeout();\n    }\n  }, timeout);\n\n  try {\n    task.fn({\n      done: function () {\n        var res = task.id === self.curId;\n        process.nextTick(function () {\n          self._next(task.id);\n        });\n        return res;\n      }\n    });\n  } catch (err) {\n    self.emit('error', err, task);\n    process.nextTick(function () {\n      self._next(task.id);\n    });\n  }\n};\n/**\n * Queue manager.\n * \n * @module\n */\n\n\nvar SeqQueueManager = module.exports;\n/**\n * Queue status: idle, welcome new tasks\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\n\nSeqQueueManager.STATUS_IDLE = 0;\n/**\n * Queue status: busy, queue is working for some tasks now\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\n\nSeqQueueManager.STATUS_BUSY = 1;\n/**\n * Queue status: closed, queue has closed and would not receive task any more \n * \t\t\t\t\tand is processing the remaining tasks now.\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\n\nSeqQueueManager.STATUS_CLOSED = 2;\n/**\n * Queue status: drained, queue is ready to be destroy\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\n\nSeqQueueManager.STATUS_DRAINED = 3;\n/**\n * Create Sequence queue\n * \n * @param  {Number} timeout a global timeout for the new queue instance\n * @return {Object}         new queue instance\n * @memberOf SeqQueueManager\n */\n\nSeqQueueManager.createQueue = function (timeout) {\n  return new SeqQueue(timeout);\n};","map":null,"metadata":{},"sourceType":"script"}