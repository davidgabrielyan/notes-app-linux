{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\n\nconst _require = require('../../utils/logger'),\n      logger = _require.logger;\n\nconst debug = logger.debugContext('connection:sqlite');\n\nconst dataTypes = require('../../data-types').sqlite;\n\nconst sequelizeErrors = require('../../errors');\n\nconst parserStore = require('../parserStore')('sqlite');\n\nconst _require2 = require('util'),\n      promisify = _require2.promisify;\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize); // We attempt to parse file location from a connection uri\n    // but we shouldn't match sequelize default host.\n\n    if (this.sequelize.options.host === 'localhost') {\n      delete this.sequelize.options.host;\n    }\n\n    this.connections = {};\n    this.lib = this._loadDialectModule('sqlite3');\n    this.refreshTypeParser(dataTypes);\n  }\n\n  async _onProcessExit() {\n    await Promise.all(Object.getOwnPropertyNames(this.connections).map(connection => promisify(callback => this.connections[connection].close(callback))()));\n    return super._onProcessExit.call(this);\n  } // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || 'default';\n    options.storage = this.sequelize.options.storage || this.sequelize.options.host || ':memory:';\n    options.inMemory = options.storage === ':memory:' ? 1 : 0;\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;\n    options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;\n\n    if (this.connections[options.inMemory || options.uuid]) {\n      return this.connections[options.inMemory || options.uuid];\n    }\n\n    if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {\n      // automatic path provision for `options.storage`\n      fs.mkdirSync(path.dirname(options.storage), {\n        recursive: true\n      });\n    }\n\n    const connection = await new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(options.storage, options.readWriteMode, err => {\n        if (err) return reject(new sequelizeErrors.ConnectionError(err));\n        debug(\"connection acquired \".concat(options.uuid));\n        resolve(this.connections[options.inMemory || options.uuid]);\n      });\n    });\n\n    if (this.sequelize.config.password) {\n      // Make it possible to define and use password for sqlite encryption plugin like sqlcipher\n      connection.run(\"PRAGMA KEY=\".concat(this.sequelize.escape(this.sequelize.config.password)));\n    }\n\n    if (this.sequelize.options.foreignKeys !== false) {\n      // Make it possible to define and use foreign key constraints unless\n      // explicitly disallowed. It's still opt-in per relation\n      connection.run('PRAGMA FOREIGN_KEYS=ON');\n    }\n\n    return connection;\n  }\n\n  releaseConnection(connection, force) {\n    if (connection.filename === ':memory:' && force !== true) return;\n\n    if (connection.uuid) {\n      connection.close();\n      debug(\"connection released \".concat(connection.uuid));\n      delete this.connections[connection.uuid];\n    }\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":null,"metadata":{},"sourceType":"script"}