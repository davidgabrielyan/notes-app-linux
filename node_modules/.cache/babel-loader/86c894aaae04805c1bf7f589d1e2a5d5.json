{"ast":null,"code":"'use strict';\n\nconst FieldFlags = require('../constants/field_flags.js');\n\nconst Charsets = require('../constants/charsets.js');\n\nconst Types = require('../constants/types.js');\n\nconst helpers = require('../helpers');\n\nconst genFunc = require('generate-function');\n\nconst parserCache = require('./parser_cache.js');\n\nconst typeNames = [];\n\nfor (const t in Types) {\n  typeNames[Types[t]] = t;\n}\n\nfunction readCodeFor(field, config, options, fieldNum) {\n  const supportBigNumbers = options.supportBigNumbers || config.supportBigNumbers;\n  const bigNumberStrings = options.bigNumberStrings || config.bigNumberStrings;\n  const timezone = options.timezone || config.timezone;\n  const dateStrings = options.dateStrings || config.dateStrings;\n  const unsigned = field.flags & FieldFlags.UNSIGNED;\n\n  switch (field.columnType) {\n    case Types.TINY:\n      return unsigned ? 'packet.readInt8();' : 'packet.readSInt8();';\n\n    case Types.SHORT:\n      return unsigned ? 'packet.readInt16();' : 'packet.readSInt16();';\n\n    case Types.LONG:\n    case Types.INT24:\n      // in binary protocol int24 is encoded in 4 bytes int32\n      return unsigned ? 'packet.readInt32();' : 'packet.readSInt32();';\n\n    case Types.YEAR:\n      return 'packet.readInt16()';\n\n    case Types.FLOAT:\n      return 'packet.readFloat();';\n\n    case Types.DOUBLE:\n      return 'packet.readDouble();';\n\n    case Types.NULL:\n      return 'null;';\n\n    case Types.DATE:\n    case Types.DATETIME:\n    case Types.TIMESTAMP:\n    case Types.NEWDATE:\n      if (helpers.typeMatch(field.columnType, dateStrings, Types)) {\n        return \"packet.readDateTimeString(\".concat(field.decimals, \");\");\n      }\n\n      return \"packet.readDateTime('\".concat(timezone, \"');\");\n\n    case Types.TIME:\n      return 'packet.readTimeString()';\n\n    case Types.DECIMAL:\n    case Types.NEWDECIMAL:\n      if (config.decimalNumbers) {\n        return 'packet.parseLengthCodedFloat();';\n      }\n\n      return 'packet.readLengthCodedString(\"ascii\");';\n\n    case Types.GEOMETRY:\n      return 'packet.parseGeometryValue();';\n\n    case Types.JSON:\n      // Since for JSON columns mysql always returns charset 63 (BINARY),\n      // we have to handle it according to JSON specs and use \"utf8\",\n      // see https://github.com/sidorares/node-mysql2/issues/409\n      return 'JSON.parse(packet.readLengthCodedString(\"utf8\"));';\n\n    case Types.LONGLONG:\n      if (!supportBigNumbers) {\n        return unsigned ? 'packet.readInt64JSNumber();' : 'packet.readSInt64JSNumber();';\n      }\n\n      if (bigNumberStrings) {\n        return unsigned ? 'packet.readInt64String();' : 'packet.readSInt64String();';\n      }\n\n      return unsigned ? 'packet.readInt64();' : 'packet.readSInt64();';\n\n    default:\n      if (field.characterSet === Charsets.BINARY) {\n        return 'packet.readLengthCodedBuffer();';\n      }\n\n      return \"packet.readLengthCodedString(CharsetToEncoding[fields[\".concat(fieldNum, \"].characterSet])\");\n  }\n}\n\nfunction compile(fields, options, config) {\n  const parserFn = genFunc();\n  let i = 0;\n  const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);\n  /* eslint-disable no-trailing-spaces */\n\n  /* eslint-disable no-spaced-func */\n\n  /* eslint-disable no-unexpected-multiline */\n\n  parserFn('(function(){')('return function BinaryRow(packet, fields, options, CharsetToEncoding) {');\n\n  if (options.rowsAsArray) {\n    parserFn(\"const result = new Array(\".concat(fields.length, \");\"));\n  }\n\n  const resultTables = {};\n  let resultTablesArray = [];\n\n  if (options.nestTables === true) {\n    for (i = 0; i < fields.length; i++) {\n      resultTables[fields[i].table] = 1;\n    }\n\n    resultTablesArray = Object.keys(resultTables);\n\n    for (i = 0; i < resultTablesArray.length; i++) {\n      parserFn(\"this[\".concat(helpers.srcEscape(resultTablesArray[i]), \"] = {};\"));\n    }\n  }\n\n  parserFn('packet.readInt8();'); // status byte\n\n  for (i = 0; i < nullBitmapLength; ++i) {\n    parserFn(\"const nullBitmaskByte\".concat(i, \" = packet.readInt8();\"));\n  }\n\n  let lvalue = '';\n  let currentFieldNullBit = 4;\n  let nullByteIndex = 0;\n  let fieldName = '';\n  let tableName = '';\n\n  for (i = 0; i < fields.length; i++) {\n    fieldName = helpers.srcEscape(fields[i].name);\n    parserFn(\"// \".concat(fieldName, \": \").concat(typeNames[fields[i].columnType]));\n\n    if (typeof options.nestTables === 'string') {\n      tableName = helpers.srcEscape(fields[i].table);\n      lvalue = \"this[\".concat(helpers.srcEscape(fields[i].table + options.nestTables + fields[i].name), \"]\");\n    } else if (options.nestTables === true) {\n      tableName = helpers.srcEscape(fields[i].table);\n      lvalue = \"this[\".concat(tableName, \"][\").concat(fieldName, \"]\");\n    } else if (options.rowsAsArray) {\n      lvalue = \"result[\".concat(i.toString(10), \"]\");\n    } else {\n      lvalue = \"this[\".concat(helpers.srcEscape(fields[i].name), \"]\");\n    } // TODO: this used to be an optimisation ( if column marked as NOT_NULL don't include code to check null\n    // bitmap at all, but it seems that we can't rely on this flag, see #178\n    // TODO: benchmark performance difference\n    //\n    // if (fields[i].flags & FieldFlags.NOT_NULL) { // don't need to check null bitmap if field can't be null.\n    //  result.push(lvalue + ' = ' + readCodeFor(fields[i], config));\n    // } else if (fields[i].columnType == Types.NULL) {\n    //  result.push(lvalue + ' = null;');\n    // } else {\n\n\n    parserFn(\"if (nullBitmaskByte\".concat(nullByteIndex, \" & \").concat(currentFieldNullBit, \")\"));\n    parserFn(\"\".concat(lvalue, \" = null;\"));\n    parserFn('else');\n    parserFn(\"\".concat(lvalue, \" = \").concat(readCodeFor(fields[i], config, options, i))); // }\n\n    currentFieldNullBit *= 2;\n\n    if (currentFieldNullBit === 0x100) {\n      currentFieldNullBit = 1;\n      nullByteIndex++;\n    }\n  }\n\n  if (options.rowsAsArray) {\n    parserFn('return result;');\n  }\n\n  parserFn('};')('})()');\n  /* eslint-enable no-trailing-spaces */\n\n  /* eslint-enable no-spaced-func */\n\n  /* eslint-enable no-unexpected-multiline */\n\n  if (config.debug) {\n    helpers.printDebugWithCode('Compiled binary protocol row parser', parserFn.toString());\n  }\n\n  return parserFn.toFunction();\n}\n\nfunction getBinaryParser(fields, options, config) {\n  return parserCache.getParser('binary', fields, options, config, compile);\n}\n\nmodule.exports = getBinaryParser;","map":null,"metadata":{},"sourceType":"script"}